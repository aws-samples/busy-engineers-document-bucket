{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"The Busy Engineer's Document Bucket","text":"<p>Welcome to the Busy Engineer's Document Bucket workshop. In this workshop, you will be guided through adding client-side encryption with KMS and the AWS Encryption SDK. Each exercise has step-by-step instructions. Each exercise also has a <code>-complete</code> version available to use as a reference.</p>"},{"location":"#background-the-document-bucket-system","title":"Background: The Document Bucket System","text":"<p>The example system you will will work on is the Document Bucket. As you begin this workshop, this system uses DynamoDB and S3 to <code>store</code>, <code>search</code>, <code>list</code>, and <code>retrieve</code> documents with associated metadata. The bodies of each document are written as S3 objects. DynamoDB maintains a pointer to that object, along with associated metadata for that object. Additionally, DynamoDB is set up to maintain records of tags used to identify the document, so that you can search for documents that match a particular tag.</p> <p></p> <p>After your work in the workshop is complete, you will have added client-side encryption with the AWS Encryption SDK and AWS KMS to the Document Bucket. Before data leaves the origin instance in <code>store</code>, it will be encrypted client-side. After the data is <code>retrieve</code>d, it will be decrypted client side with a permissions check and audit entry from AWS KMS. You will also explore options for binding and validating the metadata to the object.</p>"},{"location":"#exercises","title":"Exercises","text":"<p>In this workshop, you will work through the following exercises:</p> <ol> <li>Adding the AWS Encryption SDK</li> <li>Adding Multi-KMS-Key Support to the Document Bucket</li> <li>Working With Encryption Context</li> </ol>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Ready to start? Proceed to Getting Started to begin.</p>"},{"location":"adding-the-encryption-sdk/","title":"Exercise 1: Add the AWS Encryption SDK","text":"<p>In this section, you will add client-side encryption to the Busy Engineer's Document Bucket using the AWS Encryption SDK and AWS KMS.</p>"},{"location":"adding-the-encryption-sdk/#background","title":"Background","text":"<p>In Getting Started, you set up your Busy Engineer's Document Bucket environment and selected a workshop language. </p> <p>Now you will add the AWS Encryption SDK to encrypt objects on the client, before they are transmitted off of the host machine to the internet. You will use AWS KMS to provide a <code>data key</code> for each object, using a KMS Key that you set up in Getting Started.</p>"},{"location":"adding-the-encryption-sdk/#lets-go","title":"Let's Go!","text":""},{"location":"adding-the-encryption-sdk/#starting-directory","title":"Starting Directory","text":"<p>Make sure you are in the <code>exercises</code> directory for the language of your choice:</p> JavaTypescript Node.JSJavaScript Node.JSPython <pre><code>cd ~/environment/workshop/exercises/java/add-esdk-start\n</code></pre> <pre><code>cd ~/environment/workshop/exercises/node-typescript/add-esdk-start\n</code></pre> <pre><code>cd ~/environment/workshop/exercises/node-javascript/add-esdk-start\n</code></pre> <pre><code>cd ~/environment/workshop/exercises/python/add-esdk-start\n</code></pre>"},{"location":"adding-the-encryption-sdk/#step-1-add-the-esdk-dependency","title":"Step 1: Add the ESDK Dependency","text":"<p>Look for <code>ADD-ESDK-START</code> comments in the code to help orient yourself.</p> <p>Start by adding the Encryption SDK dependency to the code.</p> JavaTypescript Node.JSJavaScript Node.JSPython <pre><code>// Edit ./src/main/java/sfw/example/esdkworkshop/Api.java\npackage sfw.example.esdkworkshop;\n\n// ADD-ESDK-START: Add the ESDK Dependency\nimport com.amazonaws.encryptionsdk.AwsCrypto;\nimport com.amazonaws.encryptionsdk.CommitmentPolicy;\nimport com.amazonaws.encryptionsdk.CryptoResult;\nimport com.amazonaws.encryptionsdk.MasterKey;\nimport com.amazonaws.encryptionsdk.MasterKeyProvider;\nimport com.amazonaws.encryptionsdk.kms.KmsMasterKey;\n\n...\n  private final String tableName;\n  private final String bucketName;\n  // ADD-ESDK-START: Add the ESDK Dependency\n  private final AwsCrypto awsEncryptionSdk;\n  private final MasterKeyProvider mkp;\n\n...\n\npublic Api(\n    // ADD-ESDK-START: Add the ESDK Dependency\n    AmazonDynamoDB ddbClient,\n    String tableName,\n    AmazonS3 s3Client,\n    String bucketName,\n    MasterKeyProvider&lt;? extends MasterKey&gt; mkp) {\n  this.ddbClient = ddbClient;\n  this.tableName = tableName;\n  this.s3Client = s3Client\n  // ADD-ESDK-START: Add the ESDK Dependency\n  this.awsEncryptionSdk = AwsCrypto.builder()\n      .withCommitmentPolicy(CommitmentPolicy.ForbidEncryptAllowDecrypt)\n      .build();\n  this.mkp = mkp;\n}\n\n// Save and close.\n// Edit ./src/main/java/sfw/example/esdkworkshop/App.java\npackage sfw.example.esdkworkshop;\n\n// ADD-ESDK-START: Add the ESDK Dependency\nimport com.amazonaws.encryptionsdk.kms.KmsMasterKeyProvider;\n// Save and close.\n</code></pre> <pre><code>// Edit ./src/store.ts\n\n// ADD-ESDK-START: Add the ESDK Dependency\nimport { KmsKeyringNode, buildClient, CommitmentPolicy } from \"@aws-crypto/client-node\";\nconst { encryptStream } = buildClient(\n    CommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT\n)\n\n// Save and exit\n\n// Edit ./src/retrieve.ts\n\n// ADD-ESDK-START: Add the ESDK Dependency\nimport { KmsKeyringNode, buildClient, CommitmentPolicy } from \"@aws-crypto/client-node\";\nconst { decryptStream } = buildClient(\n    CommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT\n)\n\n// Save and exit\n</code></pre> <pre><code>// Edit ./store.js\n\n// ADD-ESDK-START: Add the ESDK Dependency\nconst { KmsKeyringNode, buildClient, CommitmentPolicy } = require(\"@aws-crypto/client-node\");\nconst { encryptStream } = buildClient(\n    CommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT\n)\n\n// Save and exit\n\n// Edit ./retrieve.js\n\n// ADD-ESDK-START: Add the ESDK Dependency\nconst { KmsKeyringNode, buildClient, CommitmentPolicy } = require(\"@aws-crypto/client-node\");\nconst { decryptStream } = buildClient(\n    CommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT\n)\n\n// Save and exit\n</code></pre> <pre><code># Edit src/document_bucket/__init__.py\n\n# ADD-ESDK-START: Add the ESDK Dependency\nimport aws_encryption_sdk\n\n# Save and exit\n# Edit src/document_bucket/api.py\n\n# ADD-ESDK-START: Add the ESDK Dependency\nimport aws_encryption_sdk\nfrom aws_encryption_sdk import StrictAwsKmsMasterKeyProvider  # type: ignore\nfrom aws_encryption_sdk.identifiers import CommitmentPolicy\n\n# Add a Master Key Provider to your __init__\n# ADD-ESDK-START: Add the ESDK Dependency\ndef __init__(self, bucket, table, master_key_provider: StrictAwsKmsMasterKeyProvider):\n    self.bucket = bucket\n    self.table = table\n    # ADD-ESDK-START: Add the ESDK Dependency\n    self.master_key_provider : StrictAwsKmsMasterKeyProvider = master_key_provider\n\n# Save and exit\n</code></pre>"},{"location":"adding-the-encryption-sdk/#what-happened","title":"What Happened?","text":"<ol> <li>You added a dependency on the AWS Encryption SDK library in your code</li> <li>(Java and Python) You changed the API to expect that a Keyring or Master Key Provider will be passed to your code to use in <code>store</code> and <code>retrieve</code> operations</li> </ol>"},{"location":"adding-the-encryption-sdk/#step-2-add-encryption-to-store","title":"Step 2: Add Encryption to <code>store</code>","text":"<p>Now that you have the AWS Encryption SDK imported, start encrypting your data before storing it.</p> JavaTypescript Node.JSJavaScript Node.JSPython <pre><code>// Edit ./src/main/java/sfw/example/esdkworkshop/Api.java\npublic PointerItem store(byte[] data, Map&lt;String, String&gt; context) {\n    // ADD-ESDK-START: Add Encryption to store\n    CryptoResult&lt;byte[], KmsMasterKey&gt; encryptedMessage = awsEncryptionSdk.encryptData(mkp, data);\n    DocumentBundle bundle =\n        DocumentBundle.fromDataAndContext(encryptedMessage.getResult(), context);\n    writeItem(bundle.getPointer());\n    ...\n</code></pre> <pre><code>// Edit ./src/store.ts\n\n// ADD-ESDK-START: Add Encryption to store\nconst Body = fileStream.pipe(encryptStream(encryptKeyring));\n\n// Save and exit\n</code></pre> <pre><code>// Edit ./store.js\n\n// ADD-ESDK-START: Add Encryption to store\nconst Body = fileStream.pipe(encryptStream(encryptKeyring));\n\n// Save and exit\n</code></pre> <pre><code># Edit src/document_bucket/api.py\n# Find the store function and edit it to add the Master Key Provider\n# and to write the encrypted data\n    # ADD-ESDK-START: Add Encryption to store\n    client = aws_encryption_sdk.EncryptionSDKClient(\n        commitment_policy=CommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT\n    )\n    encrypted_data, header = client.encrypt(\n        source=data,\n        key_provider=self.master_key_provider,\n    )\n    ...\n    self._write_object(encrypted_data, item)\n</code></pre>"},{"location":"adding-the-encryption-sdk/#what-happened_1","title":"What Happened?","text":"<p>The application will use the AWS Encryption SDK to encrypt your data client-side under a KMS Key before storing it by:</p> <ol> <li>Requesting a new data key using your Keyring or Master Key Provider</li> <li>Encrypting your data with the returned data key</li> <li>Returning the AWS Encryption SDK formatted encrypted message.</li> <li>Passing the encrypted message to the AWS S3 SDK for storage in S3</li> </ol>"},{"location":"adding-the-encryption-sdk/#step-3-add-decryption-to-retrieve","title":"Step 3: Add Decryption to <code>retrieve</code>","text":"<p>Now that the application encypts your data before storing it, it will need to decrypt your data before returning it to the caller (at least for the data to be useful, anyway).</p> JavaTypescript Node.JSJavaScript Node.JSPython <pre><code>// Edit ./src/main/java/sfw/example/esdkworkshop/Api.java\n// Find retrieve(...)\n    byte[] data = getObjectData(key);\n    // ADD-ESDK-START: Add Decryption to retrieve\n    CryptoResult&lt;byte[], KmsMasterKey&gt; decryptedMessage = awsEncryptionSdk.decryptData(mkp, data);\n    PointerItem pointer = getPointerItem(key);\n    // ADD-ESDK-START: Add Decryption to retrieve\n    return DocumentBundle.fromDataAndPointer(decryptedMessage.getResult(), pointer);\n</code></pre> <pre><code>// Edit ./src/retrieve.ts\n\n// ADD-ESDK-START: Add Decryption to retrieve\nreturn s3\n    .getObject({ Bucket, Key })\n    .createReadStream()\n    .pipe(decryptStream(decryptKeyring));\n\n// Save and Exit\n</code></pre> <pre><code>// Edit ./retrieve.js\n\n// ADD-ESDK-START: Add Decryption to retrieve\nreturn s3\n    .getObject({ Bucket, Key })\n    .createReadStream()\n    .pipe(decryptStream(decryptKeyring));\n\n// Save and Exit\n</code></pre> <pre><code># Edit src/document_bucket/api.py\n# Find the retrieve function and edit it to add a call to decrypt the\n# encrypted data before returning it\n        item = self._get_pointer_item(PointerQuery.from_key(pointer_key))\n        # ADD-ESDK-START: Add Decryption to retrieve\n        encrypted_data = self._get_object(item)\n        client = aws_encryption_sdk.EncryptionSDKClient(\n            commitment_policy=CommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT\n        )\n        plaintext, header = client.decrypt(\n            source=encrypted_data, key_provider=self.master_key_provider\n        )\n        return DocumentBundle.from_data_and_context(\n            plaintext, item.context\n        )\n\n# Save and exit\n</code></pre>"},{"location":"adding-the-encryption-sdk/#what-happened_2","title":"What Happened?","text":"<p>The application now decrypts data client-side, as well.</p> <p>The data returned from S3 for <code>retrieve</code> is encrypted. Before returning that data to the user, you added a call to the AWS Encryption SDK to decrypt the data. Under the hood, the Encryption SDK is:</p> <ol> <li>Reading the AWS Encryption SDK formatted encrypted message</li> <li>Calling KMS to request to decrypt your encrypted message's encrypted data key using the Faythe KMS Key</li> <li>Using the decrypted data key to decrypt the encrypted message</li> <li>Returning the plaintext and Encryption SDK headers to you</li> </ol>"},{"location":"adding-the-encryption-sdk/#step-4-configure-the-faythe-kms-key-in-the-encryption-sdk","title":"Step 4: Configure the Faythe KMS Key in the Encryption SDK","text":"<p>Now that you have declared your dependencies and updated your code to encrypt and decrypt data, the final step is to pass through the configuration to the AWS Encryption SDK to start using your KMS Keys to protect your data.</p> JavaTypescript Node.JSJavaScript Node.JSPython <pre><code>// Edit ./src/main/java/sfw/example/esdkworkshop/App.java\n    AmazonS3 s3Client = AmazonS3ClientBuilder.defaultClient();\n\n    // ADD-ESDK-START: Configure the Faythe KMS Key in the Encryption SDK\n    // Load configuration of KMS resources\n    String faytheKmsKey = stateConfig.contents.state.FaytheKmsKey;\n\n    // Set up the Master Key Provider to use KMS\n    KmsMasterKeyProvider mkp = KmsMasterKeyProvider.builder().buildStrict(faytheKmsKey);\n\n    return new Api(ddbClient, tableName, s3Client, bucketName, mkp);\n</code></pre> <pre><code>// Edit ./src/store.ts\n\n// ADD-ESDK-START: Configure the Faythe KMS Key in the Encryption SDK\nconst faytheKmsKey = config.state.getFaytheKmsKey();\nconst encryptKeyring = new KmsKeyringNode({\ngeneratorKeyId: faytheKmsKey\n});\n\n// Save and exit\n\n// Edit ./src/retrieve.ts\n\n// ADD-ESDK-START: Set up a keyring to use Faythe's KMS Key for decrypting.\nconst faytheKmsKey = config.state.getFaytheKmsKey();\nconst decryptKeyring = new KmsKeyringNode({ keyIds: [faytheKmsKey] });\n\n// Save and exit\n</code></pre> <pre><code>// Edit ./store.js\n\n// ADD-ESDK-START: Configure the Faythe KMS Key in the Encryption SDK\nconst faytheKmsKey = config.state.getFaytheKmsKey();\nconst encryptKeyring = new KmsKeyringNode({\ngeneratorKeyId: faytheKmsKey\n});\n\n// Save and exit\n\n// Edit ./retrieve.js\n\n// ADD-ESDK-START: Set up a keyring to use Faythe's KMS Key for decrypting.\nconst faytheKmsKey = config.state.getFaytheKmsKey();\nconst decryptKeyring = new KmsKeyringNode({ keyIds: [faytheKmsKey] });\n\n// Save and exit\n</code></pre> <pre><code># Edit src/document_bucket/__init__.py\n\n    ...\n\n    # ADD-ESDK-START: Configure the Faythe KMS Key in the Encryption SDK\n    # Pull configuration of KMS resources\n    faythe_kms_key = state[\"FaytheKmsKey\"]\n    # And the Master Key Provider configuring how to use KMS\n    kms_key = [faythe_kms_key]\n    mkp = aws_encryption_sdk.StrictAwsKmsMasterKeyProvider(key_ids=kms_key)\n\n    operations = DocumentBucketOperations(bucket, table, mkp)\n\n# Save and exit\n</code></pre>"},{"location":"adding-the-encryption-sdk/#what-happened_3","title":"What Happened?","text":"<p>In Getting Started, you launched CloudFormation stacks for KMS Keys. One of these KMS Keys was nicknamed Faythe. As part of launching these templates, the KMS Key's Amazon Resource Name (ARN) was written to a configuration file on disk, the <code>state</code> variable that is loaded and parsed.</p> <p>Now Faythe's ARN is pulled into a variable, and used to initialize a Keyring or Master Key Provider that will use the Faythe KMS Key. That new Keyring/Master Key Provider is passed into your API, and you are set to start encrypting and decrypting with KMS and the Encryption SDK.</p>"},{"location":"adding-the-encryption-sdk/#checking-your-work","title":"Checking Your Work","text":"<p>Want to check your progress, or compare what you've done versus a finished example?</p> <p>Check out the code in one of the <code>-complete</code> folders to compare.</p> JavaTypescript Node.JSJavaScript Node.JSPython <pre><code>cd ~/environment/workshop/exercises/java/add-esdk-complete\n</code></pre> <pre><code>cd ~/environment/workshop/exercises/node-typescript/add-esdk-complete\n</code></pre> <pre><code>cd ~/environment/workshop/exercises/node-javascript/add-esdk-complete\n</code></pre> <pre><code>cd ~/environment/workshop/exercises/python/add-esdk-complete\n</code></pre>"},{"location":"adding-the-encryption-sdk/#try-it-out","title":"Try it Out","text":"<p>Now that the code is written, let's load it up and try it out.</p> <p>If you'd like to try a finished example, use your language's <code>-complete</code> directory as described above.</p> <p>Experiment using the API as much as you like. </p> <p>To get started, here are some things to try:</p> <ul> <li>Compare CloudTrail Logs for usages of Faythe when you encrypt messages of different sizes (small, medium, large)<ul> <li>Note: Cloudtrail logs may take a couple minutes to appear in the console</li> </ul> </li> <li>Take a look at the contents of your S3 Document Bucket to inspect the raw object</li> </ul> <p>For more things to try, check out Explore Further, below.</p> JavaJavaScript Node.JSJavaScript Node.JS CLITypescript Node.JSTypescript Node.JS CLIPython <pre><code>// Compile your code\nmvn compile\n\n// To use the API programmatically, use this target to launch jshell\nmvn jshell:run\n/open startup.jsh\nApi documentBucket = App.initializeDocumentBucket();\ndocumentBucket.list();\ndocumentBucket.store(\"Store me in the Document Bucket!\".getBytes());\nfor (PointerItem item : documentBucket.list()) {\n    DocumentBundle document = documentBucket.retrieve(item.partitionKey().getS());\n    System.out.println(document.getPointer().partitionKey().getS() + \" : \" + new String(document.getData(), java.nio.charset.StandardCharsets.UTF_8));\n}\n// Ctrl+D to exit jshell\n\n// Or, to run logic that you write in App.java, use this target after compile\nmvn exec:java\n</code></pre> <pre><code>node\nlist = require(\"./list.js\")\nstore = require(\"./store.js\")\nretrieve = require(\"./retrieve\")\nlist().then(console.log)\nstore(fs.createReadStream(\"./store.js\")).then(r =&gt; {\n// Just storing the s3 key\nkey = r.Key\nconsole.log(r)\n})\nlist().then(console.log)\n(() =&gt; {retrieve(key).pipe(process.stdout)})()\n// Ctrl-D when finished to exit the REPL\n</code></pre> <pre><code>./cli.js list\n./cli.js store ./store.js\n# Note the \"Key\" value\n./cli.js list\n# Note the \"reference\" value\n./cli.js retrieve $KeyOrReferenceValue\n</code></pre> <pre><code>node -r ts-node/register\n;({list} = require(\"./src/list.ts\"))\n;({store} = require(\"./src/store.ts\"))\n;({retrieve} = require(\"./src/retrieve.ts\"))\nlist().then(console.log)\nstore(fs.createReadStream(\"./src/store.ts\")).then(r =&gt; {\n// Just storing the s3 key\nkey = r.Key\nconsole.log(r)\n})\nlist().then(console.log)\n(() =&gt; {retrieve(key).pipe(process.stdout)})()\n// Ctrl-D when finished to exit the REPL\n</code></pre> <pre><code>./cli.ts list\n./cli.ts store ./src/store.ts\n# Note the \"Key\" value\n./cli.ts list\n# Note the \"reference\" value\n./cli.ts retrieve $KeyOrReferenceValue\n</code></pre> <pre><code>tox -e repl\nimport document_bucket\nops = document_bucket.initialize()\nops.list()\nitem = ops.store(b'some data')\nops.list()\nops.retrieve(item.partition_key)\n# Ctrl-D when finished to exit the REPL\n</code></pre>"},{"location":"adding-the-encryption-sdk/#explore-further","title":"Explore Further","text":"<ul> <li>AWS Cloud Development Kit - Check out the <code>~/environment/workshop/cdk</code> directory to see how the workshop resources are described using CDK.</li> <li>Alice, Bob, and Friends - Who are Faythe and Walter?</li> <li>Leveraging the Message Format - The AWS Encryption SDK Message Format is an open standard. Can you write something to detect whether an entry in the Document Bucket has been encrypted in this format or not, and retrieve or decrypt appropriately?</li> <li>More Test Content - Small test strings are enough to get started, but you might be curious to see what the behavior and performance looks like with larger documents. What if you add support for loading files to and from disk to the Document Bucket?</li> <li>Configuration Glue - If you are curious how the Document Bucket is configured, take a peek at <code>~/environment/workshop/cdk/Makefile</code> and the <code>make state</code> target, as well as <code>config.toml</code> in the exercises root <code>~/environment/workshop/exercises/config.toml</code>. The Busy Engineer's Document Bucket uses a base TOML file to set standard names for all CloudFormation resources and a common place to discover the real deployed set. Then it uses the AWS Cloud Development Kit (CDK) to deploy the resources and write out their identifiers to the state file. Applications use the base TOML file <code>config.toml</code> to locate the state file and pull the expected resource names. And that's how the system bootstraps all the resources it needs!</li> </ul>"},{"location":"adding-the-encryption-sdk/#next-exercise","title":"Next exercise","text":"<p>Now that you are encrypting and decrypting, how about adding Multiple KMS Keys?</p>"},{"location":"clean-up-and-closing/","title":"Thank You!","text":"<p>Thank you for working through the workshop today. We hope that you found it to be useful in getting started with client-side encryption using the AWS Encryption SDK and AWS KMS.</p>"},{"location":"clean-up-and-closing/#cleaning-up","title":"Cleaning Up","text":"<p>There are helper scripts available to help you completely tear down your stack resources.</p>"},{"location":"clean-up-and-closing/#emptying-your-document-bucket","title":"Emptying Your Document Bucket","text":"<p>To remove the contents of your test S3 bucket so that CloudFormation can completely delete the stack, do the following:</p> <pre><code>cd ~/environment/workshop/cdk\nmake data_purge\n</code></pre>"},{"location":"clean-up-and-closing/#deleting-your-document-bucket-resource-stacks","title":"Deleting Your Document Bucket Resource Stacks","text":"<p>After emptying your Document Bucket, you can now use CDK to destroy your stack.</p> <pre><code>cd ~/environment/workshop/cdk\nnpx cdk destroy BusyEngineer*\n</code></pre>"},{"location":"clean-up-and-closing/#shutting-down-cloud9","title":"Shutting Down Cloud9","text":"<p>Use the CloudFormation console to delete your Cloud9 stack.</p> <ol> <li>Open the CloudFormation Console</li> <li>Select the \"BusyEngineersDocumentBucketEnvironment\" stack</li> <li>Press \"Delete\"</li> </ol>"},{"location":"clean-up-and-closing/#finished","title":"Finished!","text":"<p>That's it! Your workshop resources have been torn down. Use the CloudFormation console in both regions to confirm your resources are all successfully cleaned up.</p> <ul> <li>CloudFormation in us-east-2 (Cloud9, Document Bucket resources, Faythe)</li> <li>CloudFormation in us-east-1 (Walter)</li> </ul>"},{"location":"clean-up-and-closing/#feedback","title":"Feedback","text":"<p>We welcome comments, questions, concerns, contributions, and feature requests on our GitHub page for the Busy Engineer's Document Bucket.</p> <p>If there is content that can be improved or anything that you would like to see, we would like to cover it for you.</p> <p>At AWS Cryptography, our mission is to make tools that are easy to use, hard to misuse, and that help our customers protect their most sensitive data wherever and whenever it is.</p> <p>We look forward to hearing from you about this workshop or your needs.</p> <p>Thank you again for your time, and go forth and be secure!</p>"},{"location":"encryption-context/","title":"Exercise 3: Working With Encryption Context","text":"<p>In this section, you will work with encryption context and explore its use in the Document Bucket and other applications.</p>"},{"location":"encryption-context/#background","title":"Background","text":"<p>The Busy Engineer's Document Bucket has metadata, called <code>context</code>, associated with each document. This metadata is a set of key-value string pairs, associated with the item in DynamoDB, searchable there, and attached to the S3 object as well.</p> <p>One of the features AWS KMS and the AWS Encryption SDK both provide is called encryption context. At its core, encryption context is this metadata mapping: keys that are associated with context about the object, and values indicating information about what that context is. All the information in the map is non-secret, and is the basis for several feature integrations.</p> <p>One useful model for thinking about encryption context is as Assertions about the Five Ws: Who, What, Where, When, Why. For example:</p> <ul> <li>Who should have access to this decrypted data?</li> <li>What data is being decrypted?</li> <li>Where is the decryption happening?</li> <li>When is this data being used?</li> <li>Why is this data being decrypted?</li> </ul>"},{"location":"encryption-context/#aws-kms-kms-operations-and-encryption-context","title":"AWS KMS: KMS Operations and Encryption Context","text":"<p>AWS KMS allows you to specify an encryption context on <code>kms:Encrypt</code>. If you do so, you must provide the exact same encryption context on <code>kms:Decrypt</code>, or the operation will fail. (The match is case-sensitive, and key-value pairs are compared in an order independent way.)</p> <p>Behind the scenes, KMS is cryptographically binding the encryption context to the key material you are <code>kms:Encrypt</code> or <code>kms:Decrypt</code>ing as Additional Authenticated Data (AAD). In short, this is non-secret data that must be identical (not tampered-with or incomplete), or decryption fails.</p> <p>This feature defends against risks from ciphertexts being tampered with, modified, or replaced -- intentionally or unintentionally. It both defends against an attacker replacing one ciphertext with another as well as problems like operational events.</p> <p>For example, if a bad deployment swaps <code>us-east-1.cfg</code> with <code>eu-central-1.cfg</code> on your fleets, having <code>{ fleet: us-east-1 }</code> asserted in <code>us-east-1.cfg</code>'s encryption context will prevent it from accidentally being loaded by <code>eu-central-1</code>.</p>"},{"location":"encryption-context/#aws-kms-policy-and-audit-hooks","title":"AWS KMS: Policy and Audit Hooks","text":"<p>KMS also makes the encryption context available to use in Key Policies and Grants. This means that you can use assertions you make about your data to control usage of your KMS Keys. Perhaps your <code>eu-central-1</code> fleet should only ever be permitted to access encrypted data for <code>{ shard: europe }</code>. You can write KMS Key policies that require <code>{ shard: europe }</code> to be asserted about all cryptographic operations, so that KMS refuses to authorize an attempt to decrypt, say, <code>{ shard: north-america }</code>. These options can help you secure your application and defend against both operational and security-related risks.</p> <p>Additionally, as part of the audit features that KMS provides, it logs the encryption context that was supplied with every operation. You can use this information to audit who was accessing what data and when, to detect anomalous call patterns, or to identify unexpected system states.</p> <p>What questions would you like to answer with CloudTrail Logs for your KMS operations? encryption context can help.</p>"},{"location":"encryption-context/#the-aws-encryption-sdk","title":"The AWS Encryption SDK","text":"<p>The AWS Encryption SDK includes the encryption context as a core component. Encryption context may be supplied on encrypt -- it is optional, both for the Encryption SDK and for KMS, but strongly recommended.</p> <p>The Encryption SDK writes the encryption context in the encrypted message format. And on decrypt, the Encryption SDK validates the encryption context with KMS and returns the contents to you for you to make assertions about the contents.</p> <p>Using the Encryption SDK with KMS, you can use all of KMS' policy and audit features from encryption context, and use the Encryption SDK to make assertions to safeguard your application.</p>"},{"location":"encryption-context/#use-in-the-document-bucket","title":"Use in the Document Bucket","text":"<p>So how can encryption context be useful in the Document Bucket?</p> <p>In this exercise, you will walk through a few examples of how leveraging encryption context can help you secure and audit your application, and even build some convenience features.</p> <p>The Document Bucket already has the <code>context</code> map available for operations. It writes the <code>context</code> to the DynamoDB records for objects as well, and generates searchable DynamoDB records for context keys, to let you find documents that have certain attributes.</p> <p>Now you will plumb that context through the AWS Encryption SDK, so that KMS and the Encryption SDK bind those properties as security assertions about your data. You will also add an assertion facility to ensure that your data is what you expect it to be when you call <code>retrieve</code>.</p> <p>What this means is that with this change, you will be able to use encryption context to defend against these kind of risks:</p> <ul> <li>DynamoDB record updates that create metadata mismatches between a document and its properties</li> <li>Swapping objects in S3 so that the data is no longer what it was expected to be</li> <li>Accidentally loading the wrong data blob</li> <li>Defending against objects being listed as having a certain context key / property when they actually do not</li> </ul> <p>Also, after this change, the contents of <code>context</code> will be available in audit log entries written by KMS, and you can now use that metadata in your Key Policies and Grants.</p> <p>Remember, encryption context is not secret!</p>"},{"location":"encryption-context/#lets-go","title":"Let's Go!","text":""},{"location":"encryption-context/#starting-directory","title":"Starting Directory","text":"<p>If you just finished Using Multiple KMS Keys, you are all set.</p> <p>If you aren't sure, or want to catch up, jump into the <code>encryption-context-start</code> directory for the language of your choice.</p> JavaJavaScript Node.JSTypescript Node.JSPython <pre><code>cd ~/environment/workshop/exercises/java/encryption-context-start\n</code></pre> <pre><code>cd ~/environment/workshop/exercises/node-javascript/encryption-context-start\n</code></pre> <pre><code>cd ~/environment/workshop/exercises/node-typescript/encryption-context-start\n</code></pre> <pre><code>cd ~/environment/workshop/exercises/python/encryption-context-start\n</code></pre>"},{"location":"encryption-context/#step-1-set-encryption-context-on-encrypt","title":"Step 1: Set Encryption Context on Encrypt","text":"JavaJavaScript Node.JSTypescript Node.JSPython <pre><code>// Edit ./src/main/java/sfw/example/esdkworkshop/Api.java\n...\n\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\n...\n\n  public PointerItem store(byte[] data, Map&lt;String, String&gt; context) {\n    // ENCRYPTION-CONTEXT-START: Set Encryption Context on Encrypt\n    CryptoResult&lt;byte[], KmsMasterKey&gt; encryptedMessage =\n        awsEncryptionSdk.encryptData(mkp, data, context);\n    DocumentBundle bundle =\n        DocumentBundle.fromDataAndContext(encryptedMessage.getResult(), context);\n// Save your changes\n</code></pre> <pre><code>  // Edit ./store.js\n  // ENCRYPTION-CONTEXT-START: Set encryption context on Encrypt\n  const Body = fileStream.pipe(\n    encryptStream(encryptKeyring, { encryptionContext })\n  );\n\n// Save your changes\n</code></pre> <pre><code>  // Edit ./src/store.ts\n  // ENCRYPTION-CONTEXT-START: Set encryption context on Encrypt\n  const Body = fileStream.pipe(\n    encryptStream(encryptKeyring, { encryptionContext })\n  );\n\n// Save your changes\n</code></pre> <pre><code># Edit src/document_bucket/api.py\n# Find the store(...) function, and add context to the encrypt call\n\n        # ENCRYPTION-CONTEXT-START: Set encryption context on Encrypt\n        encrypted_data, header = self.encryption_client.encrypt(\n            source=data,\n            key_provider=self.master_key_provider,\n            encryption_context=context,\n        )\n\n# Save your changes\n</code></pre>"},{"location":"encryption-context/#what-happened","title":"What Happened?","text":"<p>The Document Bucket <code>context</code> will now be supplied to the AWS Encryption SDK and AWS KMS as encryption context. If a non-empty key-value pair map is supplied to <code>store</code>, those key-value pairs will be used in encryption and decryption operations all the way through to KMS:</p> <ul> <li>The contents of <code>context</code> will appear in KMS audit logs.</li> <li>The contents of <code>context</code> will be availble to use in KMS Key Policies and Grants to make authorization decisions.</li> <li>The contents of <code>context</code> will be written to the Encryption SDK message.</li> <li>Supplying the exact-match contents of <code>context</code> will be required to decrypt any encrypted data keys.</li> <li>The contents of <code>context</code> will now be available on Decrypt to use in making assertions.</li> </ul> <p>Next you will update <code>retrieve</code> to use the encryption context on decrypt.</p>"},{"location":"encryption-context/#step-2-use-encryption-context-on-decrypt","title":"Step 2: Use Encryption Context on Decrypt","text":"JavaJavaScript Node.JSTypescript Node.JSPython <pre><code>// Edit ./src/main/java/sfw/example/esdkworkshop/Api.java and find retrieve(...)\n    // ENCRYPTION-CONTEXT-START: Use Encryption Context on Decrypt\n    Map&lt;String, String&gt; actualContext = decryptedMessage.getEncryptionContext();\n    PointerItem pointer = PointerItem.fromKeyAndContext(key, actualContext);\n// Save your changes\n</code></pre> <pre><code>// Edit ./retrieve.js\n\n  return (\n    s3\n      .getObject({ Bucket, Key })\n      .createReadStream()\n      .pipe(decryptStream(decryptKeyring))\n      // ENCRYPTION-CONTEXT-START: Making Assertions\n      .once(\"MessageHeader\", function(header) {\n\n      })\n  );\n\n// Save your changes\n</code></pre> <pre><code>// Edit ./src/retrieve.ts\n\n  return (\n    s3\n      .getObject({ Bucket, Key })\n      .createReadStream()\n      .pipe(decryptStream(decryptKeyring))\n      // ENCRYPTION-CONTEXT-START: Making Assertions\n      .once(\"MessageHeader\", function(this: Writable, header: MessageHeader) {\n\n      })\n  );\n\n// Save your changes\n</code></pre> <pre><code># Edit src/document_bucket/api.py\n# Find the retrieve(...) function, and use the Encryption SDK header's encryption\n# context to construct the DocumentBundle to return\n\n        # ENCRYPTION-CONTEXT-START: Use encryption context on Decrypt\n        return DocumentBundle.from_data_and_context(\n            plaintext, header.encryption_context\n        )\n\n# Save your changes\n</code></pre>"},{"location":"encryption-context/#what-happened_1","title":"What Happened?","text":"<p>Now on decrypt, the validated encryption context from the Encryption SDK Message Format header will be passed back to the application. Any business logic that would benefit from using the encryption context data for making decisions can use the version bound and validated by the Encryption SDK and KMS.</p> <p>Next you will add a mechanism for the application to test assertions made in encryption context before working with the returned data.</p>"},{"location":"encryption-context/#step-3-making-assertions","title":"Step 3: Making Assertions","text":"JavaJavaScript Node.JSTypescript Node.JSPython <pre><code>// Edit ./src/main/java/sfw/example/esdkworkshop/Api.java and find retrieve(...)\n    // ENCRYPTION-CONTEXT-START: Making Assertions\n    boolean allExpectedContextKeysFound = actualContext.keySet().containsAll(expectedContextKeys);\n    if (!allExpectedContextKeysFound) {\n        // Remove all of the keys that were found\n        expectedContextKeys.removeAll(actualContext.keySet());\n        String error =\n        String.format(\n            \"Expected context keys were not found in the actual encryption context! \"\n            + \"Missing keys were: %s\",\n            expectedContextKeys.toString());\n      throw new DocumentBucketException(error, new NoSuchElementException());\n    }\n    boolean allExpectedContextFound =\n        actualContext.entrySet().containsAll(expectedContext.entrySet());\n    if (!allExpectedContextFound) {\n        Set&lt;Map.Entry&lt;String, String&gt;&gt; expectedContextEntries = expectedContext.entrySet();\n        expectedContextEntries.removeAll(actualContext.entrySet());\n        String error =\n            String.format(\n                \"Expected context pairs were not found in the actual encryption context! \"\n                + \"Missing pairs were: %s\",\n                expectedContextEntries.toString());\n        throw new DocumentBucketException(error, new NoSuchElementException());\n    }\n// Save your work\n</code></pre> <pre><code>// Edit ./retrieve.js\n  return (\n    s3\n      .getObject({ Bucket, Key })\n      .createReadStream()\n      .pipe(decryptStream(decryptKeyring))\n      // ENCRYPTION-CONTEXT-START: Making Assertions\n      .once(\"MessageHeader\", function(header) {\n        const { encryptionContext } = header;\n        const pairs = Object.entries(expectedContext || {});\n        const keys = (expectedContextKeys || []).slice();\n        if (\n          !(\n            pairs.every(([key, value]) =&gt; encryptionContext[key] === value) &amp;&amp;\n            keys.every(key =&gt;\n              Object.hasOwnProperty.call(encryptionContext, key)\n            )\n          )\n        ) {\n          this.emit(\n            \"error\",\n            new Error(\"Encryption context does not match expected shape\")\n          );\n        }\n      })\n  );\n\n// Save your changes\n</code></pre> <pre><code>// Edit ./src/retrieve.ts\n  import { EC } from \"./store\";\n  import { Writable } from \"stream\";\n  const Bucket = config.state.bucketName();\n\n  ...\n  return (\n    s3\n      .getObject({ Bucket, Key })\n      .createReadStream()\n      .pipe(decryptStream(decryptKeyring))\n      // ENCRYPTION-CONTEXT-START: Making Assertions\n      .once(\"MessageHeader\", function(this: Writable, header: MessageHeader) {\n        const { encryptionContext } = header;\n        const pairs = Object.entries(expectedContext || {});\n        const keys = (expectedContextKeys || []).slice();\n        if (\n          !(\n            pairs.every(([key, value]) =&gt; encryptionContext[key] === value) &amp;&amp;\n            keys.every(key =&gt;\n              Object.hasOwnProperty.call(encryptionContext, key)\n            )\n          )\n        ) {\n          this.emit(\n            \"error\",\n            new Error(\"Encryption context does not match expected shape\")\n          );\n        }\n      })\n  );\n\n// Save your changes\n</code></pre> <pre><code># Edit src/document_bucket/api.py\n# Find the retrieve(...) function, and add some assertions about the contents\n# of the encryption context validated by the Encryption SDK\n\n        # ENCRYPTION-CONTEXT-START: Making Assertions\n        if not expected_context_keys &lt;= header.encryption_context.keys():\n            error_msg = (\n                \"Encryption context assertion failed! \"\n                f\"Expected all these keys: {expected_context_keys}, \"\n                f\"but got {header.encryption_context}!\"\n            )\n            raise AssertionError(error_msg)\n        if not expected_context.items() &lt;= header.encryption_context.items():\n            error_msg = (\n                \"Encryption context assertion failed! \"\n                f\"Expected {expected_context}, \"\n                f\"but got {header.encryption_context}!\"\n            )\n            raise AssertionError(error_msg)\n        # ENCRYPTION-CONTEXT-START: Use Encryption Context on Decrypt\n        return DocumentBundle.from_data_and_context(\n            plaintext, header.encryption_context\n        )\n</code></pre>"},{"location":"encryption-context/#what-happened_2","title":"What Happened?","text":"<p><code>retrieve</code> will use its \"expected context keys\" argument to validate that all of those keys (with any associated values) are present in the encryption context. <code>retrieve</code> will also use its \"expected context\" argument to validate that the exact key-value pairs specified in expected context are present in the actual encryption context. If either of those assumptions is invalid, <code>retrieve</code> will raise an exception before returning the data. These assertions safeguard against accidentally returning unintended, corrupted, or tampered data to the application.</p> <p>Now the Document Bucket will use AWS KMS and the AWS Encryption SDK to ensure that the <code>context</code> metadata is consistent throughout the lifetime of the objects, resistant to tampering or corruption, and make the validated context available to the application logic to make additional business logic assertions safely.</p>"},{"location":"encryption-context/#checking-your-work","title":"Checking Your Work","text":"<p>If you want to check your progress, or compare what you've done versus a finished example, check out the code in one of the <code>-complete</code> folders to compare.</p> <p>There is a <code>-complete</code> folder for each language.</p> JavaJavaScript Node.JSTypescript Node.JSPython <pre><code>cd ~/environment/workshop/exercises/java/encryption-context-complete\n</code></pre> <pre><code>cd ~/environment/workshop/exercises/node-javascript/encryption-context-complete\n</code></pre> <pre><code>cd ~/environment/workshop/exercises/node-typescript/encryption-context-complete\n</code></pre> <pre><code>cd ~/environment/workshop/exercises/python/encryption-context-complete\n</code></pre>"},{"location":"encryption-context/#try-it-out","title":"Try it Out","text":"<p>Now that you pass encryption context all the way through to KMS and validate it on return, what assertions do you want to make about your data?</p> <p>Here's some ideas for things to test:</p> <ul> <li>Expecting exact match of key-value pairs for keys like <code>stage</code>, <code>shard</code>, and <code>source-fleet</code></li> <li>Expecting a set of keys to be present like <code>submit-date</code> and <code>category</code></li> <li>Expecting an exact match of a subset of the supplied key-value pairs (e.g. only <code>stage</code> and <code>shard</code>, not <code>source-fleet</code>)</li> <li>Doing the same for expected keys with any value</li> <li>Adding a constraint of a new key that you didn't supply at encryption time</li> <li>Adding a constraint with a different value, like <code>stage=production</code></li> <li>Changing capitalization</li> <li>Using sorted versus unsorted mappings, such as <code>java.util.SortedMap&lt;K, V&gt;</code> in Java or <code>collections.OrderedDict</code> in Python</li> </ul> <p>There's a few simple suggestions to get you started in the snippets below.</p> JavaJavaScript Node.JSJavaScript Node.JS CLITypescript Node.JSTypescript Node.JS CLIPython <pre><code>// Compile your code\nmvn compile\n\n// To use the API programmatically, use this target to launch jshell\nmvn jshell:run\n/open startup.jsh\nimport java.util.HashMap;\nApi documentBucket = App.initializeDocumentBucket();\nHashMap&lt;String, String&gt; context = new HashMap&lt;String, String&gt;();\ncontext.put(\"shard\", \"test\");\ncontext.put(\"app\", \"document-bucket\");\ncontext.put(\"origin\", \"development\");\ndocumentBucket.list();\nPointerItem item = documentBucket.store(\"Store me in the Document Bucket!\".getBytes(), context);\nDocumentBundle document = documentBucket.retrieve(item.partitionKey().getS(), context);\nSystem.out.println(document.getPointer().partitionKey().getS() + \" : \" + new String(document.getData(), java.nio.charset.StandardCharsets.UTF_8));\n// Ctrl+D to exit jshell\n\n// Or, to run logic that you write in App.java, use this target after compile\nmvn exec:java\n</code></pre> <pre><code>node\nlist = require(\"./list.js\")\nstore = require(\"./store.js\")\nretrieve = require(\"./retrieve\")\nlist().then(console.log)\nencryptionContext = {\n  stage: \"demo\",\n  purpose: \"simple demonstration\",\n  origin: \"us-east-2\"\n}\nstore(fs.createReadStream(\"./store.js\"), encryptionContext).then(r =&gt; {\n  // Just storing the s3 key\n  key = r.Key\n  console.log(r)\n})\nlist().then(console.log)\nretrieve(key, { expectedContext: { stage: \"demo\"}, expectedContextKeys: [ \"purpose\" ] }).pipe(process.stdout)\n// Ctrl-D when finished to exit the REPL\n</code></pre> <pre><code>./cli.js list\n./cli.js store ./store.js \\\n  -c \"stage:demo\" \\\n  -c \"purpose:simple demonstration\" \\\n  -c \"origin:us-east-2\"\n# Note the \"Key\" value\n./cli.js list\n# Note the \"reference\" value\n./cli.js retrieve $KeyOrReferenceValue \\\n  -c \"stage:demo\" \\\n  -k purpose\n</code></pre> <pre><code>node -r ts-node/register\n;({list} = require(\"./src/list.ts\"))\n;({store} = require(\"./src/store.ts\"))\n;({retrieve} = require(\"./src/retrieve.ts\"))\nlist().then(console.log)\nencryptionContext = {\n  stage: \"demo\",\n  purpose: \"simple demonstration\",\n  origin: \"us-east-2\"\n}\nstore(fs.createReadStream(\"./src/store.ts\"), encryptionContext).then(r =&gt; {\n  // Just storing the s3 key\n  key = r.Key\n  console.log(r)\n})\nlist().then(console.log)\nretrieve(key, { expectedContext: { stage: \"demo\"}, expectedContextKeys: [ \"purpose\" ] }).pipe(process.stdout)\n// Ctrl-D when finished to exit the REPL\n</code></pre> <pre><code>./cli.ts list\n./cli.ts store ./src/store.ts \\\n  -c \"stage:demo\" \\\n  -c \"purpose:simple demonstration\" \\\n  -c \"origin:us-east-2\"\n# Note the \"Key\" value\n./cli.ts list\n# Note the \"reference\" value\n./cli.ts retrieve $KeyOrReferenceValue \\\n  -c \"stage:demo\" \\\n  -k purpose\n</code></pre> <pre><code>tox -e repl\nimport document_bucket\nops = document_bucket.initialize()\ncontext = {\"host\": \"cloud9\", \"shard\": \"development\", \"purpose\": \"experimental\"}\nops.list()\nitem = ops.store(b'some data', context)\nprint(ops.retrieve(item.partition_key, expected_context=context))\n# Ctrl-D when finished to exit the REPL\n</code></pre>"},{"location":"encryption-context/#explore-further","title":"Explore Further","text":"<p>Encryption context can provide different types of features and guardrails in your application logic. Consider these ideas for further exploration:</p> <ul> <li>Detecting Drift - <code>context</code> contents are stored on the DynamoDB item. S3 has object metadata that could also use the <code>context</code> pairs. How would you use the validated encryption context to validate and guardrail those two data sources? What could that feature add to your application?</li> <li>Meta-operations on Encryption Context - the encryption context is stored on the open-specification AWS Encryption SDK Message Format. Would it help your system to write tools to process the metadata -- such as the encryption context -- on the message format?</li> <li>DynamoDB Keys and Indexes - the Document Bucket adds composite indexes by <code>context</code> key. What about adding composite keys by key-value pairs? If you know a particular key should always be present in well-formed encrypted data, perhaps that should also be a Secondary Index?</li> <li>Enforing EC Keys - If you know that there is a key that should always be present, and that you want to index on in DynamoDB, do you want to enforce that it's always present? You can extend the Cryptographic Materials Manager component in the AWS Encryption SDK to enforce this during cryptographic operations.</li> <li>Alarms and Monitoring - How can you leverage encryption context and CloudWatch Alarms for CloudTrail to monitor and protect your application?</li> </ul>"},{"location":"encryption-context/#next-exercise","title":"Next exercise","text":"<p>Congratulations! You have officially completed the Busy Engineer's Document Bucket workshop. Proceed to Clean Up and Closing to tear down your workshop environment.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#workshop-details","title":"Workshop Details","text":"<p>In this workshop, you will add encryption and decryption features to the Busy Engineer's Document Bucket to learn about some real world AWS patterns for integrating client-side encryption using AWS Key Management Service (AWS KMS) and the AWS Encryption SDK (ESDK) in application code. You will learn how to leverage features like multiple AWS KMS Key support and Encryption Context to secure your application.</p> <p>To begin, the Document Bucket supports storing objects (documents or files or other blobs of data) in a private Amazon S3 bucket, and indexing them in Amazon DynamoDB. This allows Document Bucket users to share objects with other users, and store them for retrieval later. The DynamoDB entries provide metadata context for each Document Bucket object, as well as fast lookups to the provided context.</p> <p>This context allows users to store additional information about the S3 object like the origin user, the destination fleet, the project, or any other tag that would be useful to know without having to download and examine the object.</p> <p>DynamoDB is configured to allow you to index on the keys associated with the S3 objects. So, for example, it's a quick query to find out which objects have been tagged with metadata context that includes \"configuration\".</p> <p>The Document Bucket supports the following APIs:</p> <ul> <li><code>list</code>: This operation queries DynamoDB for all entries for all objects in the Document Bucket, and their metadata. It returns the <code>set</code> of items that have been stored.</li> <li><code>store</code>: This operation accepts a blob of bytes and a <code>map</code> of metadata context. It generates a unique identifier (UID) for the object. The UID and associated metadata are written to DynamoDB. The bytes of the object are written to S3 under a key of that UID. Any context metadata keys in DynamoDB are updated to include that new UID.</li> <li><code>retrieve</code>: This operation accepts a unique identifier (UID) as an argument. It looks up the UID in DynamoDB to identify the associated context and then retrieves the referenced object from S3. It returns the Document Bundle (UID, context, and referenced object) to the caller.</li> <li><code>search</code>: This operation accepts a metadata key as search input. It queries DynamoDB for the <code>set</code> of objects in the Document Bucket with context matching that key. It returns the <code>set</code> of UIDs and their associated metadata.<ul> <li>Once you have identified the desired object(s), you can pass the UIDs to <code>retrieve</code> to fetch the objects.</li> </ul> </li> </ul> <p>This is a start for sharing, storing, and searching various objects. </p> <p>But what about sensitive documents? Or protecting, say, important configuration files from accidental corruption during storing or retrieving? </p> <p>The workshop exercises will help you address some of these challenges.</p>"},{"location":"getting-started/#background","title":"Background","text":"<p>In this section, we will give you step-by-step instructions to prepare your AWS Environment to work with the Busy Engineer's Document Bucket. </p> <p>To set up your environment, you will:</p> <ul> <li>Deploy a CloudFormation stack to launch an AWS Cloud9 integrated development environment (IDE)</li> <li>AWS Cloud9 lets you write, run, and debug your code with just a browser</li> <li>Launch the Cloud9 IDE that you will use for the rest of the workshop</li> <li>Launch resource stacks using the AWS Cloud Development Kit (CDK), including:<ul> <li>The <code>BusyEngineersDocumentBucket</code> stack, with your DynamoDB table and S3 bucket</li> <li>One KMS Key in one region, called Faythe, that you will use in encryption and decryption operations</li> <li>One KMS Key in another region, called Walter, that you will use in encryption and decryption operations</li> </ul> </li> <li>Bootstrap the development environment in Cloud9</li> </ul>"},{"location":"getting-started/#lets-go","title":"Let's Go!","text":""},{"location":"getting-started/#important-note-about-accounts","title":"Important Note About Accounts","text":"<p>If you are using your own AWS Account for this workshop, make sure:</p> <ol> <li>It is not a production account. This is a workshop for learning and experimentation. Don't put production at risk!</li> <li>When you are done with the exercises, you follow the instructions in Clean Up and Closing to clean up the deployed resources.</li> </ol> <p>If you are working through these exercises in an AWS classroom environment, AWS accounts have been created for you.</p>"},{"location":"getting-started/#procedure","title":"Procedure","text":"<ol> <li>Sign in to your AWS Account for the workshop</li> <li>Click this link to load the CloudFormation template for your Cloud9 IDE<ul> <li>The above link should put you in the US East (Ohio) region</li> <li>Do not change your region settings from the default and do not switch regions in the console</li> </ul> </li> <li>Click Create Stack to launch the stack<ul> <li>It will take about three minutes to launch your Cloud9 IDE</li> </ul> </li> <li>Click this link to Open the Cloud9 Console and find your Cloud9 IDE<ul> <li>You may need to wait a minute and refresh while CloudFormation spins up the resources</li> <li>There will be a blue tile titled BusyEngineersCloud9IDE when it's ready</li> </ul> </li> <li>At the bottom of the tile, click Open IDE to launch Cloud9</li> <li>Type <code>cd ~/environment/workshop</code> and hit <code>Enter</code></li> <li>Type <code>make bootstrap</code> and hit <code>Enter</code> to set up your workshop environment<ul> <li><code>make bootstrap</code> will take approximately 10 minutes to complete</li> <li>While you wait, you may get started reading the first exercise, Adding the Encryption SDK</li> <li>You can even go ahead and start making code changes as per the exercise instructions, but you'll need to wait for the bootstrap to complete before running any code</li> <li>Keep an eye on the terminal running the bootstrap, and once it completes come back to these steps.</li> </ul> </li> <li>Once the bootstrap completes you will see <code>*** BOOTSTRAP COMPLETE ***</code><ul> <li>At this point you have deployed your workshop stacks using CDK and set up language environments for all of the workshop languages</li> </ul> </li> <li>In Cloud9, close your Terminal window and open a new one (<code>Window -&gt; New Terminal</code>) to pick up the changes <code>make bootstrap</code> installed</li> <li>Choose your workshop language, and <code>cd</code> to its folder under <code>exercises</code></li> </ol> JavaTypescript Node.JSJavaScript Node.JSPython <pre><code>cd ~/environment/workshop/exercises/java\n</code></pre> <pre><code>cd ~/environment/workshop/exercises/node-typescript\n</code></pre> <pre><code>cd ~/environment/workshop/exercises/node-javascript\n</code></pre> <pre><code>cd ~/environment/workshop/exercises/python\n</code></pre> <p>Your environment is ready! </p>"},{"location":"getting-started/#start-the-workshop","title":"Start the workshop!","text":"<p>Now that you have your environment and language selected, you can start Adding the Encryption SDK.</p>"},{"location":"multi-kms-key/","title":"Exercise 2: Adding Multi-KMS-Key Support to the Document Bucket","text":"<p>In this section, you will configure the AWS Encryption SDK to use multiple KMS Keys that reside in different regions.</p>"},{"location":"multi-kms-key/#background","title":"Background","text":"<p>Now your Document Bucket will encrypt files when you <code>store</code> them, and will decrypt the files for you when you <code>retrieve</code> them.</p> <p>You're using one of your KMS Keys, Faythe. But what if you want to use multiple KMS Keys?</p> <p>You might want to use a partner team's KMS Key, so that they can access documents relevant to them.</p> <p>Perhaps you want the Document Bucket to have two independent regions to access the contents, for high availability, or to put the contents closer to the recipients.</p> <p>Configuring multiple KMS Keys this way does not require re-encryption of the document data. That's because the data is still encrypted with a single data key, used exclusively for that document. Configuring multiple KMS Keys causes the AWS Encryption SDK to encrypt that data key again using the additional KMS Keys, and store that additional version of the data key on the encrypted message format. As long as there is one available KMS Key to decrypt any encrypted version of the data key, the document will be accessible.</p> <p>(There are ways to configure the Encryption SDK to be more restrictive about which KMS Keys it will try -- but for now you'll start with the simple case.)</p> <p>There's many reasons why using more than one KMS Key can be useful. And in this exercise, you're going to see how to set that up with KMS and the Encryption SDK.</p> <p>You already have another KMS Key waiting to be used. When you deployed the Faythe KMS Key, you also deployed a second KMS Key, nicknamed Walter. In this exercise, we're going to configure Walter, and then use some scripts in the repository to add and remove permission to use each of Faythe and Walter. Doing so will change how your document is encrypted -- if you remove permission to both Faythe and Walter, you won't be able to encrypt or decrypt anymore! -- and let you observe how the system behavior changes when keys are accessible or inaccessible.</p> <p>Each attempt to use a KMS Key is checked against that KMS Key's permissions. An audit trail entry is also written to CloudTrail.</p> <p>Decryption attempts will continue for each version of the encrypted data key until the Encryption SDK either succeds at decrypting an encrypted data key with its associated KMS Key, or runs out of encrypted data keys to try.</p> <p>For encryption, the Encryption SDK will attempt to use every KMS Key it is configured to attempt to produce another encryption of that data key.</p> <p>You'll get to see all of this in action in just a minute, after a couple small code changes.</p>"},{"location":"multi-kms-key/#lets-go","title":"Let's Go!","text":""},{"location":"multi-kms-key/#starting-directory","title":"Starting Directory","text":"<p>If you just finished Adding the Encryption SDK, you are all set.</p> <p>If you aren't sure, or want to catch up, jump into the <code>multi-kms-key-start</code> directory for the language of your choice.</p> JavaTypescript Node.JSJavaScript Node.JSPython <pre><code>cd ~/environment/workshop/exercises/java/multi-kms-key-start\n</code></pre> <pre><code>cd ~/environment/workshop/exercises/node-typescript/multi-kms-key-start\n</code></pre> <pre><code>cd ~/environment/workshop/exercises/node-javascript/multi-kms-key-start\n</code></pre> <pre><code>cd ~/environment/workshop/exercises/python/multi-kms-key-start\n</code></pre>"},{"location":"multi-kms-key/#step-1-configure-walter","title":"Step 1: Configure Walter","text":"JavaJavaScript Node.JSTypescript Node.JSPython <pre><code>// Edit ./src/main/java/sfw/example/esdkworkshop/App.java\n    String faytheKmsKey = stateConfig.contents.state.faytheKmsKey;\n    // MULTI-KMS-KEY-START: Configure Walter\n    String walterKmsKey = stateConfig.contents.state.WalterKmsKey;\n</code></pre> <pre><code>// Edit ./store.js\n// MULTI-KMS-KEY-START: Configure Walter\nconst walterKmsKey = config.state.getWalterKmsKey();\n\n// Edit ./retrieve.js\n// MULTI-KMS-KEY-START: Configure Walter\nconst walterKmsKey = config.state.getWalterKmsKey();\n</code></pre> <pre><code>// Edit ./src/store.ts\n// MULTI-KMS-KEY-START: Configure Walter\nconst walterKmsKey = config.state.getWalterKmsKey();\n\n// Edit ./src/retrieve.ts\n// MULTI-KMS-KEY-START: Configure Walter\nconst walterKmsKey = config.state.getWalterKmsKey();\n</code></pre> <pre><code># Edit src/document_bucket/__init__.py\n\n    # MULTI-KMS-KEY-START: Configure Walter\n    walter_kms_key = state[\"WalterKmsKey\"]\n</code></pre>"},{"location":"multi-kms-key/#what-happened","title":"What Happened?","text":"<p>When you launched your workshop stacks in Getting Started, along with the Faythe KMS Key, you also launched a KMS Key called Walter. Walter's ARN was also plumbed through to the configuration state file that is set up for you by the workshop. Now that ARN is being pulled into a variable to use in the Encryption SDK configuration.</p>"},{"location":"multi-kms-key/#step-2-add-walter-to-the-kms-keys-to-use","title":"Step 2: Add Walter to the KMS Keys to Use","text":"JavaJavaScript Node.JSTypescript Node.JSPython <pre><code>// Edit ./src/main/java/sfw/example/esdkworkshop/App.java\n    // MULTI-KMS-KEY-START: Add Walter to the KMS Keys to Use\n    KmsMasterKeyProvider mkp = KmsMasterKeyProvider.builder().buildStrict(faytheKmsKey, walterKmsKey);\n</code></pre> <pre><code>// Edit ./store.js\n// MULTI-KMS-KEY-START: Add Walter to the KMS Keys to Use\n...\nconst encryptKeyring = new KmsKeyringNode({\n  generatorKeyId: faytheKmsKey,\n  keyIds: [walterKmsKey]\n});\n\n// Save and exit\n// Edit ./retrieve.js\n// MULTI-KMS-KEY-START: Add Walter to the KMS Keys to Use\n...\nconst decryptKeyring = new KmsKeyringNode({ keyIds: [faytheKmsKey, walterKmsKey] });\n\n// Save and exit\n</code></pre> <pre><code>// Edit ./src/store.ts\n// MULTI-KMS-KEY-START: Add Walter to the KMS Keys to Use\n...\nconst encryptKeyring = new KmsKeyringNode({\n  generatorKeyId: faytheKmsKey,\n  keyIds: [walterKmsKey]\n});\n\n// Save and exit\n// Edit ./src/retrieve.ts\n// MULTI-KMS-KEY-START: Add Walter to the KMS Keys to Use\n...\nconst decryptKeyring = new KmsKeyringNode({ keyIds: [faytheKmsKey, walterKmsKey] });\n\n// Save and exit\n</code></pre> <pre><code># Edit src/document_bucket/__init__.py\n\n    # MULTI-KMS-KEY-START: Add Walter to the KMS Keys to Use\n    kms_key = [faythe_kms_key, walter_kms_key]\n\n# Save and exit\n</code></pre>"},{"location":"multi-kms-key/#what-happened_1","title":"What Happened?","text":"<p>In the previous exercise, you configured the Encryption SDK to use a list of KMS Keys that contained only Faythe. Configuring the Encryption SDK to also use Walter for encrypt, and to also try Walter for decrypt, required adding the ARN for Walter to the configuration list.</p>"},{"location":"multi-kms-key/#checking-your-work","title":"Checking Your Work","text":"<p>If you want to check your progress, or compare what you've done versus a finished example, check out the code in one of the <code>-complete</code> folders to compare.</p> <p>There is a <code>-complete</code> folder for each language.</p> JavaTypescript Node.JSJavaScript Node.JSPython <pre><code>cd ~/environment/workshop/exercises/java/multi-kms-key-complete\n</code></pre> <pre><code>cd ~/environment/workshop/exercises/node-typescript/multi-kms-key-complete\n</code></pre> <pre><code>cd ~/environment/workshop/exercises/node-javascript/multi-kms-key-complete\n</code></pre> <pre><code>cd ~/environment/workshop/exercises/python/multi-kms-key-complete\n</code></pre>"},{"location":"multi-kms-key/#try-it-out","title":"Try it Out","text":"<p>Adding the Walter KMS Key to the list of KMS Keys that the application will (attempt) to use was a couple of lines of code, but has powerful implications.</p> <p>To help you explore the behavior of the system, there are some additional <code>make</code> targets to change the permissions configuration of Faythe and Walter.</p> <p>Using these targets, you can add and remove permission for the application to use Faythe and Walter to generate data keys, encrypt, and decrypt, and observe how the application behavior changes -- as well as what is logged to CloudTrail.</p> <p>In <code>~/environment/workshop/exercises</code>, you'll find a <code>Makefile</code> with several targets for you to experiment with:</p> <ul> <li><code>make list_grants</code> will show you the current state of grants on your KMS Keys</li> <li><code>make revoke_walter_grant</code> will remove the Grant providing permissions to use Walter in the application</li> <li><code>make revoke_faythe_grant</code> will remove the Grant providing permissions to use Faythe in the application</li> <li><code>make revoke_grants</code> will remove the Grants for both KMS Keys</li> <li><code>make create_grants</code> will add Grants to use either or both KMS Key, as needed</li> </ul> <p>Note: When you create or revoke a grant there might be a brief delay, usually less than five minutes, until the grant is available throughout AWS KMS.</p> <p>Important when you revoke permissions to the first KMS Key in the list for a keyring (which is Faythe by default), you will need to change the keyring configuration to use Walter as your generator to resume operations. See documentation of Generator KMS Keys for more.</p> <p>You can also observe the impact of changing Granted permissions by monitoring CloudTrail. Note that log entries take a few minutes to propagate to CloudTrail, and that Faythe and Walter are in different regions, so you will need to look at CloudTrail in the region for each one.</p> <ul> <li>Faythe is in <code>us-east-2</code>, so check CloudTrail in that region with these links:<ul> <li>GenerateDataKey operations in CloudTrail in us-east-2</li> <li>Decrypt operations in CloudTrail in us-east-2</li> <li>Encrypt operations in CloudTrail in us-east-2<ul> <li>Note: To observe Encrypt calls using Faythe, explore some of the configuration and permissions changes suggested below.</li> </ul> </li> </ul> </li> <li>Walter is in <code>us-east-1</code>, so check CloudTrail in that region with these links:<ul> <li>GenerateDataKey operations in CloudTrail in us-east-1</li> <li>Encrypt operations in CloudTrail in us-east-1</li> <li>Decrypt operations in CloudTrail in us-east-1</li> </ul> </li> </ul> <p>Try out combinations of Grant permissions for your application and watch how the behavior changes:</p> <ul> <li>Revoke permission to use Faythe, and watch calls move to Walter in CloudTrail and in your application</li> <li>With permission to use Faythe revoked, try retrieving an older document protected by Faythe</li> <li>Revoke permissions to both Faythe and Walter -- now operations fail</li> <li>Encrypt some data with both Faythe and Walter active, and revoke permission to either one -- notice that application operations continue to work</li> <li>Change the configuration order of Faythe and Walter, and watch how call patterns change to use the two KMS Keys</li> <li>Revoke permission to Walter, and encrypt some data with Faythe. Then, add permission back to Walter, revoke permission to use Faythe, and try to decrypt that data</li> <li>What other interesting access patterns can you imagine?</li> </ul> JavaJavaScript Node.JSJavaScript Node.JS CLITypescript Node.JSTypescript Node.JS CLIPython <pre><code>// Compile your code\nmvn compile\n\n// To use the API programmatically, use this target to launch jshell\nmvn jshell:run\n/open startup.jsh\nApi documentBucket = App.initializeDocumentBucket();\ndocumentBucket.list();\nPointerItem item = documentBucket.store(\"Store me in the Document Bucket!\".getBytes());\nDocumentBundle document = documentBucket.retrieve(item.partitionKey().getS());\nSystem.out.println(document.getPointer().partitionKey().getS() + \" : \" + new String(document.getData(), java.nio.charset.StandardCharsets.UTF_8));\n// Ctrl+D to exit jshell\n\n// Use the make targets to change the Grants and see what happens!\n// To run logic that you write in App.java, use this target after compile\nmvn exec:java\n</code></pre> <pre><code>node\nlist = require(\"./list.js\")\nstore = require(\"./store.js\")\nretrieve = require(\"./retrieve\")\nlist().then(console.log)\nstore(fs.createReadStream(\"./store.js\")).then(r =&gt; {\n  // Just storing the s3 key\n  key = r.Key\n  console.log(r)\n})\nlist().then(console.log)\nretrieve(key).pipe(process.stdout)\n// Use the make targets to change the Grants and see what happens!\n// Ctrl-D when finished to exit the REPL\n</code></pre> <pre><code>./cli.js list\n./cli.js store ./store.js\n# Note the \"Key\" value\n./cli.js list\n# Note the \"reference\" value\n./cli.js retrieve $KeyOrReferenceValue\n# Use the make targets to change the grants and see what happens!\n</code></pre> <pre><code>node -r ts-node/register\n;({list} = require(\"./src/list.ts\"))\n;({store} = require(\"./src/store.ts\"))\n;({retrieve} = require(\"./src/retrieve.ts\"))\nlist().then(console.log)\nstore(fs.createReadStream(\"./src/store.ts\")).then(r =&gt; {\n  // Just storing the s3 key\n  key = r.Key\n  console.log(r)\n})\nlist().then(console.log)\nretrieve(key).pipe(process.stdout)\n// Ctrl-D when finished to exit the REPL\n// Use the make targets to change the Grants and see what happens!\n</code></pre> <pre><code>./cli.ts list\n./cli.ts store ./src/store.ts\n# Note the \"Key\" value\n./cli.ts list\n# Note the \"reference\" value\n./cli.ts retrieve $KeyOrReferenceValue\n# Use the make targets to change the grants and see what happens!\n</code></pre> <pre><code>tox -e repl\nimport document_bucket\nops = document_bucket.initialize()\nops.list()\nitem = ops.store(b'some data')\nops.retrieve(item.partition_key)\n# Use the make targets to change the grants and see what happens!\n# Ctrl-D when finished to exit the REPL\n</code></pre>"},{"location":"multi-kms-key/#explore-further","title":"Explore Further","text":"<p>Want to dive into more content related to this exercise? Try out these links.</p> <ul> <li>AWS KMS: Key Grants</li> <li>AWS KMS: Key Policies</li> <li>AWS KMS: Cross-account KMS Key Usage</li> <li>Blog Post: How to decrypt ciphertexts in multiple regions with the AWS Encryption SDK in C</li> </ul>"},{"location":"multi-kms-key/#next-exercise","title":"Next exercise","text":"<p>Ready for more? Next you will work with Encryption Context.</p>"},{"location":"tips-and-troubleshooting/","title":"Tips and Troubleshooting","text":"<p>This page contains reference information that might be useful as you work through the workshop.</p>"},{"location":"tips-and-troubleshooting/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tips-and-troubleshooting/#errors-with-configuration","title":"Errors with configuration","text":"<p>If you are getting a <code>NullPointerException</code> (Java), or a <code>KeyError</code> (Python), or similar errors when interacting with the TOML files (config and state), try running the state generation step again to make sure the file is generated and well formed.</p> <pre><code># Check the contents of your state file\ncat ~/.busy_engineers_state.toml\n\n# Regenerate your state file, if needed\ncd ~/environment/workshop/cdk/\nmake state\n</code></pre> <p>Now try your work again.</p>"},{"location":"tips-and-troubleshooting/#automated-code-checks","title":"Automated code checks","text":"<p>These commands will check your code for missing imports, syntax issues, and other minor issues that might trip you up.</p> JavaJavaScript Node.JSTypescript Node.JSPython <pre><code>mvn verify\n</code></pre> <pre><code>npm run prettier\n</code></pre> <pre><code>npm run prettier\n</code></pre> <pre><code>tox -e check\n</code></pre>"},{"location":"tips-and-troubleshooting/#missing-cloudformation-resources","title":"Missing CloudFormation resources","text":"<p>Make sure you take the defaults for which region to launch in (us-east-2). If you've changed the region for any part of the workshop, tear your stack down and start fresh.</p>"},{"location":"tips-and-troubleshooting/#more-disk-space-on-cloud9","title":"More disk space on Cloud9","text":"<p>Working through the workshop, you might find that you are out of disk. If this happens, use the following script to expand your EBS volume. (Script source)</p> <p>Note that this is adapted from the script source because the Busy Engineer's Cloud9 instances run on EC2 Nitro, which has different block device identifiers.</p> <p>Step by step:</p> <ol> <li>Save the script below to <code>resize.sh</code></li> <li><code>chmod +x resize.sh</code></li> <li><code>./resize.sh</code></li> <li>By default, this will increase your volume to 20GB, but you may supply a different number if you prefer.</li> </ol> <pre><code>#!/bin/bash\n\n# Specify the desired volume size in GiB as a command-line argument. If not specified, default to 20 GiB.\nSIZE=${1:-20}\n\n# Install the jq command-line JSON processor.\nsudo yum -y install jq\n\n# Get the ID of the envrionment host Amazon EC2 instance.\nINSTANCEID=$(curl http://169.254.169.254/latest/meta-data//instance-id)\n\n# Get the ID of the Amazon EBS volume associated with the instance.\nVOLUMEID=$(aws ec2 describe-instances --instance-id $INSTANCEID | jq -r .Reservations[0].Instances[0].BlockDeviceMappings[0].Ebs.VolumeId)\n\n# Resize the EBS volume.\naws ec2 modify-volume --volume-id $VOLUMEID --size $SIZE\n\n# Wait for the resize to finish.\nwhile [ \"$(aws ec2 describe-volumes-modifications --volume-id $VOLUMEID --filters Name=modification-state,Values=\"optimizing\",\"completed\" | jq '.VolumesModifications | length')\" != \"1\" ]; do\n  sleep 1\n  done\n\n# Rewrite the partition table so that the partition takes up all the space that it can.\nsudo growpart /dev/nvme0n1p1 1\n\n# Expand the size of the file system.\nsudo resize2fs /dev/nvme0n1p1\n</code></pre>"},{"location":"tips-and-troubleshooting/#tips","title":"Tips","text":""},{"location":"tips-and-troubleshooting/#api-documentation","title":"API Documentation","text":"<p>Python and Java have API documentation available for each exercise. You can view the documentation as you work in Cloud9.</p> JavaPython <pre><code>make javadoc\n</code></pre> <pre><code>tox -e docs\n</code></pre> <p>Now select \"Preview -&gt; Preview Running Application\" from the Cloud9 menu bar.</p> <p>Cloud9 will open a new pane in your IDE with a web browser rendering your API documentation.</p>"},{"location":"tips-and-troubleshooting/#cloud9","title":"Cloud9","text":"<p>Cloud9 has lots of IDE features for you to leverage. Here's some links to help you make the most of your Cloud9 experience. (Links all open in a new window.)</p> <ul> <li>Cloud9 Code Navigation</li> <li>Cloud9 Keybindings</li> <li>Cloud9 Tutorial</li> </ul>"},{"location":"tips-and-troubleshooting/#cryptographic-details","title":"Cryptographic Details","text":"<p>The Busy Engineer's Document Bucket only scratches the surface of the features offered by AWS KMS. To dive deep on how KMS can be useful to your application, check out the AWS Key Management Service Cryptographic Details Docs, for more information on the details of encryption, decryption, random number generation procedures, and more within KMS.</p>"}]}